#!/usr/bin/env node
import * as path from 'path';
import * as fs from 'fs';
import * as console from 'console';
import type {Writable} from 'stream';
import * as fg from 'fast-glob';
import {createCLIArgumentsParser} from './createCLIArgumentsParser';
import {serializeDefinitionMap} from './serializeDefinitionMap';
import {getVersion} from './getVersion';
import {fileSearchArgumentDefinition} from './nlibfgCLI';
import {dictionaryAsc} from './sort';

const parse = createCLIArgumentsParser({
    ...fileSearchArgumentDefinition,
    output: {
        type: 'string',
        alias: 'o',
        description: 'A file path indexen writes to',
    },
    ext: {
        type: 'boolean',
        description: 'Output "./module.js" instead of "./module"',
    },
    doubleQuote: {
        type: 'boolean',
        description: 'Use " for string literals',
    },
    help: {
        type: 'boolean',
        alias: 'h',
        description: 'Show help',
    },
    version: {
        type: 'boolean',
        alias: 'v',
        description: 'Output the version number',
    },
});
const getImportSource = (
    file: string,
    extensions: Array<string>,
    cwd: string,
) => {
    const matchedExtension = extensions.find((ext) => file.endsWith(ext));
    let id = path.relative(cwd, file).split(path.sep).join('/');
    if (matchedExtension) {
        id = id.slice(0, -matchedExtension.length);
    }
    if (!id.startsWith('.')) {
        id = `./${id}`;
    }
    if (id.endsWith('/index')) {
        id = id.slice(0, -6);
    }
    return id;
};
export const indexenHeader = '// Generated by @nlib/nodetool indexen';
export const indexenCLI = async (
    args: Array<string>,
    stdout: Writable = process.stdout,
): Promise<void> => {
    if (args.includes('--help') || args.includes('-h')) {
        stdout.write('indexen --input path/to/dir --output path/to/dir/index.js\n\n');
        for (const help of serializeDefinitionMap(parse.definition)) {
            stdout.write(help);
        }
    } else if (args.includes('--version') || args.includes('-v')) {
        stdout.write(`${getVersion(path.join(__dirname, '../package.json'))}\n`);
    } else {
        const props = parse(args);
        const cwd = props.cwd || process.cwd();
        const output = path.resolve(cwd, props.output);
        const outputDirectory = path.dirname(output);
        const sources = new Set<string>();
        const extensions = props.ext ? [] : ['.cjs', '.mjs', '.jsx', '.tsx', '.js', '.ts'];
        for await (const item of fg.stream(props.include, {cwd, ignore: props.exclude, absolute: true})) {
            const file = `${item}`;
            if (!file.endsWith('.d.ts')) {
                sources.add(getImportSource(file, extensions, outputDirectory));
            }
        }
        sources.delete(getImportSource(output, extensions, outputDirectory));
        const stream = fs.createWriteStream(output);
        stream.write(`${indexenHeader}\n`);
        const quote = props.doubleQuote ? '"' : '\'';
        for (const source of [...sources].sort(dictionaryAsc)) {
            stream.write(`export * from ${quote}${source}${quote};\n`);
        }
        stream.close();
    }
};

if (require.main === module) {
    indexenCLI(process.argv.slice(2))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });
}
